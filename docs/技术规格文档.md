# å´”å­ç‘¾è¯±æ•å™¨ - æŠ€æœ¯è§„æ ¼æ–‡æ¡£

## ğŸ”§ æŠ€æœ¯æ¶æ„è¯¦ç»†è®¾è®¡

### 1. åº”ç”¨æ¶æ„å›¾

```mermaid
graph TB
    subgraph "æ¸²æŸ“è¿›ç¨‹ (React)"
        A[ç™»å½•ç•Œé¢] --> B[ä¸»æ§åˆ¶ç•Œé¢]
        B --> C[è®¾ç½®ç•Œé¢]
        D[çŠ¶æ€ç®¡ç† Zustand] --> A
        D --> B
        D --> C
    end
    
    subgraph "ä¸»è¿›ç¨‹ (Electron)"
        E[åº”ç”¨æ§åˆ¶å™¨] --> F[ä»£ç†æœåŠ¡ç®¡ç†]
        E --> G[æ•°æ®åº“ç®¡ç†]
        E --> H[å®‰å…¨ç®¡ç†]
        E --> I[ç³»ç»Ÿé›†æˆ]
    end
    
    subgraph "ä»£ç†æœåŠ¡è¿›ç¨‹"
        J[HTTPä»£ç†æœåŠ¡å™¨] --> K[HTTPSå¤„ç†]
        J --> L[åŸŸåè¿‡æ»¤]
        J --> M[è¯·æ±‚æ‹¦æˆª]
    end
    
    subgraph "æ•°æ®å±‚"
        N[SQLiteæ•°æ®åº“] --> O[ç”¨æˆ·é…ç½®]
        N --> P[é»‘åå•æ•°æ®]
        N --> Q[æ“ä½œæ—¥å¿—]
    end
    
    A -.-> E
    B -.-> E
    C -.-> E
    E --> J
    E --> N
```

### 2. æ ¸å¿ƒæ¨¡å—è®¾è®¡

#### 2.1 ä»£ç†æœåŠ¡å™¨æ¨¡å—
```typescript
// src/main/proxy/ProxyServer.ts
export class ProxyServer {
  private server: http.Server;
  private httpsServer: https.Server;
  private port: number;
  private blockedDomains: Set<string>;
  
  async start(config: ProxyConfig): Promise<void> {
    // å¯åŠ¨HTTPä»£ç†æœåŠ¡å™¨
    // ç”Ÿæˆè‡ªç­¾åè¯ä¹¦
    // é…ç½®HTTPSå¤„ç†
  }
  
  async stop(): Promise<void> {
    // åœæ­¢ä»£ç†æœåŠ¡å™¨
    // æ¸…ç†èµ„æº
  }
  
  updateBlocklist(domains: string[]): void {
    // æ›´æ–°é»‘åå•
    // é€šçŸ¥æ‰€æœ‰è¿æ¥
  }
  
  private handleRequest(req: http.IncomingMessage, res: http.ServerResponse): void {
    // å¤„ç†HTTPè¯·æ±‚
    // æ£€æŸ¥åŸŸåæ˜¯å¦è¢«é˜»æ­¢
    // è¿”å›æ‹¦æˆªé¡µé¢æˆ–è½¬å‘è¯·æ±‚
  }
  
  private handleConnect(req: http.IncomingMessage, socket: net.Socket, head: Buffer): void {
    // å¤„ç†HTTPS CONNECTè¯·æ±‚
    // å»ºç«‹éš§é“æˆ–æ‹’ç»è¿æ¥
  }
}
```

#### 2.2 ç³»ç»Ÿé›†æˆæ¨¡å—
```typescript
// src/main/system/SystemIntegration.ts
export class SystemIntegration {
  async setSystemProxy(port: number): Promise<boolean> {
    // Windows: ä¿®æ”¹æ³¨å†Œè¡¨
    // macOS: ä½¿ç”¨networksetupå‘½ä»¤
    // Linux: ä¿®æ”¹ç¯å¢ƒå˜é‡
  }
  
  async installCertificate(certPath: string): Promise<boolean> {
    // å®‰è£…æ ¹è¯ä¹¦åˆ°ç³»ç»Ÿä¿¡ä»»å­˜å‚¨
  }
  
  async detectProxyChanges(): Promise<boolean> {
    // ç›‘æ§ç³»ç»Ÿä»£ç†è®¾ç½®å˜åŒ–
  }
  
  async protectProcess(): Promise<void> {
    // è¿›ç¨‹ä¿æŠ¤æœºåˆ¶
  }
}
```

#### 2.3 æ•°æ®è®¿é—®å±‚
```typescript
// src/main/database/DatabaseManager.ts
export class DatabaseManager {
  private db: Database;
  
  async initialize(): Promise<void> {
    // åˆå§‹åŒ–SQLiteæ•°æ®åº“
    // åˆ›å»ºè¡¨ç»“æ„
    // æ•°æ®è¿ç§»
  }
  
  async authenticateUser(password: string): Promise<boolean> {
    // éªŒè¯ç”¨æˆ·å¯†ç 
  }
  
  async getBlockedSites(): Promise<BlockedSite[]> {
    // è·å–é»‘åå•ç½‘ç«™
  }
  
  async addBlockedSite(site: CreateBlockedSiteDto): Promise<BlockedSite> {
    // æ·»åŠ ç½‘ç«™åˆ°é»‘åå•
  }
  
  async updateSiteStatus(id: string, enabled: boolean): Promise<void> {
    // æ›´æ–°ç½‘ç«™å¯ç”¨çŠ¶æ€
  }
  
  async resetAllSites(): Promise<void> {
    // é‡ç½®æ‰€æœ‰ç½‘ç«™çŠ¶æ€
  }
}
```

### 3. å‰ç«¯æ¶æ„è®¾è®¡

#### 3.1 çŠ¶æ€ç®¡ç†
```typescript
// src/renderer/store/useAppStore.ts
interface AppState {
  // è®¤è¯çŠ¶æ€
  isAuthenticated: boolean;
  user: User | null;
  
  // ç½‘ç«™ç®¡ç†
  blockedSites: BlockedSite[];
  isLoading: boolean;
  
  // ä»£ç†çŠ¶æ€
  proxyStatus: 'running' | 'stopped' | 'error';
  interceptCount: number;
  
  // UIçŠ¶æ€
  theme: 'light' | 'dark';
  currentPage: string;
}

interface AppActions {
  // è®¤è¯æ“ä½œ
  login: (password: string) => Promise<boolean>;
  logout: () => void;
  
  // ç½‘ç«™ç®¡ç†æ“ä½œ
  loadBlockedSites: () => Promise<void>;
  addSite: (url: string) => Promise<void>;
  toggleSite: (id: string) => Promise<void>;
  deleteSite: (id: string) => Promise<void>;
  resetAllSites: () => Promise<void>;
  
  // ä»£ç†æ“ä½œ
  startProxy: () => Promise<void>;
  stopProxy: () => Promise<void>;
}
```

#### 3.2 ç»„ä»¶æ¶æ„
```typescript
// é¡µé¢ç»„ä»¶
src/renderer/pages/
â”œâ”€â”€ LoginPage.tsx          # ç™»å½•é¡µé¢
â”œâ”€â”€ DashboardPage.tsx      # ä¸»æ§åˆ¶å°
â”œâ”€â”€ SettingsPage.tsx       # è®¾ç½®é¡µé¢
â””â”€â”€ EmergencyPage.tsx      # ç´§æ€¥é‡ç½®é¡µé¢

// é€šç”¨ç»„ä»¶
src/renderer/components/
â”œâ”€â”€ common/
â”‚   â”œâ”€â”€ Button.tsx         # æŒ‰é’®ç»„ä»¶
â”‚   â”œâ”€â”€ Input.tsx          # è¾“å…¥æ¡†ç»„ä»¶
â”‚   â”œâ”€â”€ Switch.tsx         # å¼€å…³ç»„ä»¶
â”‚   â””â”€â”€ Modal.tsx          # æ¨¡æ€æ¡†ç»„ä»¶
â”œâ”€â”€ layout/
â”‚   â”œâ”€â”€ Header.tsx         # é¡¶éƒ¨å¯¼èˆª
â”‚   â”œâ”€â”€ Sidebar.tsx        # ä¾§è¾¹æ 
â”‚   â””â”€â”€ Layout.tsx         # å¸ƒå±€å®¹å™¨
â””â”€â”€ features/
    â”œâ”€â”€ SiteList.tsx       # ç½‘ç«™åˆ—è¡¨
    â”œâ”€â”€ SiteCard.tsx       # ç½‘ç«™å¡ç‰‡
    â”œâ”€â”€ AddSiteForm.tsx    # æ·»åŠ ç½‘ç«™è¡¨å•
    â””â”€â”€ StatusBar.tsx      # çŠ¶æ€æ 
```

### 4. å®‰å…¨æœºåˆ¶å®ç°

#### 4.1 è¿›ç¨‹ä¿æŠ¤
```typescript
// src/main/security/ProcessProtection.ts
export class ProcessProtection {
  private watchdog: NodeJS.Timer;
  private childProcesses: ChildProcess[] = [];
  
  async initialize(): Promise<void> {
    // å¯åŠ¨çœ‹é—¨ç‹—è¿›ç¨‹
    // ç›‘æ§ä¸»è¿›ç¨‹çŠ¶æ€
    // è®¾ç½®è¿›ç¨‹é‡å¯æœºåˆ¶
  }
  
  async protectMainProcess(): Promise<void> {
    // é˜²æ­¢è¿›ç¨‹è¢«å¼ºåˆ¶ç»“æŸ
    // éšè—è¿›ç¨‹ä¿¡æ¯
  }
  
  private startWatchdog(): void {
    // å®šæœŸæ£€æŸ¥è¿›ç¨‹çŠ¶æ€
    // è‡ªåŠ¨é‡å¯å¼‚å¸¸è¿›ç¨‹
  }
}
```

#### 4.2 é…ç½®åŠ å¯†
```typescript
// src/main/security/ConfigEncryption.ts
export class ConfigEncryption {
  private readonly algorithm = 'aes-256-gcm';
  private key: Buffer;
  
  async encryptConfig(data: any): Promise<string> {
    // åŠ å¯†é…ç½®æ•°æ®
  }
  
  async decryptConfig(encryptedData: string): Promise<any> {
    // è§£å¯†é…ç½®æ•°æ®
  }
  
  private generateKey(): Buffer {
    // ç”ŸæˆåŠ å¯†å¯†é’¥
  }
}
```

### 5. ç½‘ç»œæ‹¦æˆªå®ç°

#### 5.1 HTTPä»£ç†å¤„ç†
```typescript
// src/main/proxy/HttpHandler.ts
export class HttpHandler {
  handleRequest(req: http.IncomingMessage, res: http.ServerResponse): void {
    const url = new URL(req.url!);
    const domain = url.hostname;
    
    if (this.isBlocked(domain)) {
      this.sendBlockedPage(res, domain);
      this.logInterception(domain);
      return;
    }
    
    this.forwardRequest(req, res);
  }
  
  private sendBlockedPage(res: http.ServerResponse, domain: string): void {
    const html = this.generateBlockedPageHtml(domain);
    res.writeHead(200, { 'Content-Type': 'text/html' });
    res.end(html);
  }
  
  private generateBlockedPageHtml(domain: string): string {
    return `
      <!DOCTYPE html>
      <html>
        <head>
          <title>è®¿é—®è¢«é˜»æ­¢</title>
          <style>
            body { 
              font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto;
              text-align: center; 
              padding: 50px;
              background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
              color: white;
            }
            .container {
              max-width: 500px;
              margin: 0 auto;
              background: rgba(255,255,255,0.1);
              padding: 40px;
              border-radius: 20px;
              backdrop-filter: blur(10px);
            }
          </style>
        </head>
        <body>
          <div class="container">
            <h1>ğŸš« è®¿é—®è¢«é˜»æ­¢</h1>
            <p>ç½‘ç«™ <strong>${domain}</strong> å·²è¢«å´”å­ç‘¾è¯±æ•å™¨é˜»æ­¢è®¿é—®</p>
            <p>å¦‚éœ€è§£é™¤é™åˆ¶ï¼Œè¯·è¿”å›åº”ç”¨è¿›è¡Œè®¾ç½®</p>
          </div>
        </body>
      </html>
    `;
  }
}
```

#### 5.2 HTTPSå¤„ç†
```typescript
// src/main/proxy/HttpsHandler.ts
export class HttpsHandler {
  private certificates: Map<string, tls.SecureContext> = new Map();
  
  handleConnect(req: http.IncomingMessage, socket: net.Socket, head: Buffer): void {
    const [hostname, port] = req.url!.split(':');
    
    if (this.isBlocked(hostname)) {
      socket.write('HTTP/1.1 200 Connection Established\r\n\r\n');
      this.createHttpsProxy(socket, hostname);
      return;
    }
    
    this.forwardConnect(req, socket, head);
  }
  
  private createHttpsProxy(socket: net.Socket, hostname: string): void {
    const cert = this.getCertificate(hostname);
    const tlsSocket = new tls.TLSSocket(socket, {
      secureContext: cert,
      isServer: true
    });
    
    tlsSocket.on('data', (data) => {
      // è§£æHTTPSè¯·æ±‚å¹¶è¿”å›é˜»æ­¢é¡µé¢
      this.handleHttpsRequest(tlsSocket, data, hostname);
    });
  }
}
```

### 6. æ„å»ºå’Œéƒ¨ç½²é…ç½®

#### 6.1 Electron Builderé…ç½®
```json
// electron-builder.json
{
  "appId": "com.cuizijin.trap",
  "productName": "å´”å­ç‘¾è¯±æ•å™¨",
  "directories": {
    "output": "dist"
  },
  "files": [
    "build/**/*",
    "node_modules/**/*"
  ],
  "mac": {
    "category": "public.app-category.utilities",
    "icon": "assets/icon.icns",
    "hardenedRuntime": true,
    "entitlements": "assets/entitlements.mac.plist"
  },
  "win": {
    "target": "nsis",
    "icon": "assets/icon.ico",
    "requestedExecutionLevel": "requireAdministrator"
  },
  "linux": {
    "target": "AppImage",
    "icon": "assets/icon.png"
  }
}
```

#### 6.2 å¼€å‘è„šæœ¬
```json
// package.json scripts
{
  "scripts": {
    "dev": "concurrently \"npm run dev:main\" \"npm run dev:renderer\"",
    "dev:main": "electron-webpack dev",
    "dev:renderer": "vite",
    "build": "npm run build:main && npm run build:renderer",
    "build:main": "electron-webpack",
    "build:renderer": "vite build",
    "dist": "electron-builder",
    "dist:mac": "electron-builder --mac",
    "dist:win": "electron-builder --win",
    "dist:linux": "electron-builder --linux"
  }
}
```

---

**æ–‡æ¡£ç‰ˆæœ¬ï¼š** v1.0  
**æœ€åæ›´æ–°ï¼š** 2025-06-28
